"""
Publish Markdown files to Confluence wiki.

Copyright 2022-2026, Levente Hunyadi

:see: https://github.com/hunyadi/md2conf
"""

import re
import xml.etree.ElementTree
from typing import Any

import markdown


def _emoji_generator(
    index: str,
    shortname: str,
    alias: str | None,
    uc: str | None,
    alt: str,
    title: str | None,
    category: str | None,
    options: dict[str, Any],
    md: markdown.Markdown,
) -> xml.etree.ElementTree.Element:
    """
    Custom generator for `pymdownx.emoji`.
    """

    name = (alias or shortname).strip(":")
    emoji = xml.etree.ElementTree.Element("x-emoji", {"data-shortname": name})
    if uc is not None:
        emoji.attrib["data-unicode"] = uc

        # convert series of Unicode code point hexadecimal values into characters
        emoji.text = "".join(chr(int(item, base=16)) for item in uc.split("-"))
    else:
        emoji.text = alt

    return emoji


def _verbatim_formatter(
    source: str,
    language: str,
    css_class: str,
    options: dict[str, Any],
    md: markdown.Markdown,
    classes: list[str] | None = None,
    id_value: str = "",
    attrs: dict[str, str] | None = None,
    **kwargs: Any,
) -> str:
    """
    Custom formatter for `pymdownx.superfences`.

    Used by language `math` (a.k.a. `pymdownx.arithmatex`) and pseudo-language `csf` (Confluence Storage Format pass-through).
    """

    if classes is None:
        classes = [css_class]
    else:
        classes.insert(0, css_class)

    html_id = f' id="{id_value}"' if id_value else ""
    html_class = ' class="{}"'.format(" ".join(classes))
    html_attrs = " " + " ".join(f'{k}="{v}"' for k, v in attrs.items()) if attrs else ""

    return f"<div{html_id}{html_class}{html_attrs}>{source}</div>"


_CONVERTER = markdown.Markdown(
    extensions=[
        "admonition",
        "footnotes",
        "markdown.extensions.tables",
        "md_in_html",
        "pymdownx.arithmatex",
        "pymdownx.caret",
        "pymdownx.emoji",
        "pymdownx.highlight",  # required by `pymdownx.superfences`
        "pymdownx.magiclink",
        "pymdownx.mark",
        "pymdownx.superfences",
        "pymdownx.tilde",
        "sane_lists",
    ],
    extension_configs={
        "footnotes": {"BACKLINK_TITLE": ""},  # spellchecker:disable-line
        "pymdownx.arithmatex": {"generic": True, "preview": False, "tex_inline_wrap": ["", ""], "tex_block_wrap": ["", ""]},
        "pymdownx.emoji": {"emoji_generator": _emoji_generator},
        "pymdownx.highlight": {
            "use_pygments": False,
        },
        "pymdownx.superfences": {
            "custom_fences": [
                {"name": "math", "class": "arithmatex", "format": _verbatim_formatter},
                {"name": "csf", "class": "csf", "format": _verbatim_formatter},
            ]
        },
    },
)


def markdown_to_html(content: str) -> str:
    """
    Converts a Markdown document into XHTML with Python-Markdown.

    :param content: Markdown input as a string.
    :returns: XHTML output as a string.
    :see: https://python-markdown.github.io/
    """

    _CONVERTER.reset()
    html = _CONVERTER.convert(content)
    return html


_FENCED_CODE_REGEXP = re.compile(r"^\s*(?:`{3,}|~{3,})", re.MULTILINE)


def markdown_with_line_numbers(input_lines: list[str], start_line_number: int) -> list[str]:
    """
    Injects XHTML line number markers in Markdown text.

    Unfortunately, Python-Markdown doesn't propagate line numbers to downstream processors, making it challenging to
    display helpful error messages to end users. This function injects XHTML self-closing tags into the Markdown source:

    ```
    <line-number value="#" />
    ```

    When tree visitors process the XHTML content generated by Python-Markdown and an error is triggered, the exception
    handler can use these placeholder elements to guide end users in which part of the Markdown file they should look
    by translating a tree node in the intermediate output into a line number in the source.

    :param input_lines: Markdown source file split into lines.
    :param start_line_number: The first line of the Markdown document excluding front-matter, or 1 if there is no front-matter.
    """

    output_lines: list[str] = []

    fence_marker: str | None = None
    for number, line in enumerate(input_lines, start=start_line_number):
        if not line:
            output_lines.append("")
            continue

        # fenced code blocks
        fence_match = _FENCED_CODE_REGEXP.match(line)
        if fence_match:
            marker = fence_match.group()
            if fence_marker is None:
                fence_marker = marker
            elif marker == fence_marker:
                fence_marker = None
        elif (
            # not inside a fenced code block
            fence_marker is None
            # not an admonition
            and not line.startswith("!!! ")
            # not a Setext heading
            and not (line.startswith("===") or line.startswith("---"))
            # not a decorated ATX heading
            and not line.endswith("#")
            # not a math block formula
            and not (line.startswith("$$") and line.endswith("$$"))
            # not a Markdown table
            and not (line.startswith("|") or line.endswith("|"))
            # not a block-level HTML tag
            and not (line.startswith("<") or line.endswith(">"))
        ):
            line = f'{line}<line-number value="{number}" />'

        output_lines.append(line)

    return output_lines
